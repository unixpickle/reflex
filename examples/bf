#########################
# Brainf*ck interpreter #
#########################

io = "stdlib/io".import!

# A stack which is prefilled with infinite zeroes.
Stack = {
  prefix = ^.Stack # infinite prefix of all 0's
  item = 0
  push = { # argument: x
    result = ^^.Stack(prefix=^, item:=x)
  }
}

# A bidirectional tape, represented as one stack to the left
# and one to the right.
Tape = {
  left = ^.Stack
  right = ^.Stack

  # Current position of the tape is arbitrarily chosen to be the left's end
  cur = left.item

  move_right = @(
    left := left.push(x:=right.item)!
    right := right.prefix
  )
  move_left = @(
    left := left.prefix
    right := right.push(x:=left.item)!
  )

  increment = @(
    left := left(item:=(cur + 1) % 256)
  )
  decrement = @(
    left := left(item:=(cur - 1) % 256)
  )

  # Unit test for moving around the tape; test! should be 1.
  test = ^^.unit_test[
    t = ^^.Tape.increment.move_right.increment.increment.move_left.move_left
    a = t.cur == 0
    b = t.move_right.cur == 1
    c = t.move_right.move_right.cur == 2
    d = t.move_right.move_right.move_right.cur == 0
    e = t.move_right.move_right.move_right.move_left.cur == 2
  ]
}

# Representation of the program source and the current instruction pointer.
# Override the 'code' definition to pass the program source as a string.
Program = {
  ip = 0 # instruction pointer

  cur_inst = code.substr(start=ip end=ip + 1)!
  advanced = @(ip:=ip + 1)
  rewound = @(ip:=ip - 1)

  # Matching routine for brackets
  # Arguments: next_matcher, open_symbol, close_symbol
  _matcher = {
    depth = 0

    on_open = next_matcher(depth:=depth + 1)!
    on_close = depth <= 1
      ? ^.advanced
      : next_matcher(depth:=depth - 1)!
    on_other = next_matcher(depth:=depth)!

    result = ^.cur_inst == open_symbol
      ? on_open
      : ^.cur_inst == close_symbol
        ? on_close
        : on_other
  }

  # Jump to a matching close bracket for an open bracket, then advance.
  match_open = _match_open!
  _match_open = _matcher(next_matcher=advanced._match_open, open_symbol="[", close_symbol="]")

  # Jump to a matching open bracket for a close bracket, then advance.
  match_close = _match_close!
  _match_close = _matcher(next_matcher=rewound._match_close, open_symbol="]", close_symbol="[")

  # Unit test for matching brackets; result is 1 when passed.
  test = ^^.unit_test[
    p = ^^.Program[code=".[.[..]<><>[]].[]"]
    a = p.cur_inst == "."
    b = p.advanced.match_open.ip == 14
    c = p.advanced.advanced.advanced.match_open.ip == 7
    d = p.advanced.advanced.advanced.match_open.rewound.match_close.ip == 4
    e = p[ip=13].match_close.ip == 2
  ]
}

# A code interpreter, which represents the current program state.
# Use the 'result' definition to get the terminated interpreter state.
Interpreter = {
  success = 1 # mark the program as successful

  program = ^^.Program[code=^.code]
  tape = ^^.Tape

  is_open_bracket = program.cur_inst == "["
  is_close_bracket = program.cur_inst == "]"
  is_lt = program.cur_inst == "<"
  is_gt = program.cur_inst == ">"
  is_plus = program.cur_inst == "+"
  is_minus = program.cur_inst == "-"
  is_dot = program.cur_inst == "."
  is_done = program.cur_inst == ""

  stop = @
  step = @(program:=program.advanced)
  run_lt = step(tape:=tape.move_left)!
  run_gt = step(tape:=tape.move_right)!
  run_minus = step(tape:=tape.decrement)!
  run_plus = step(tape:=tape.increment)!
  run_dot = ^^.io.stdout.write(bytes=tape.cur.chr.bytes)! && step!
  run_open_bracket = @(
    program := tape.cur ? program.advanced :  program.match_open
  )!
  run_close_bracket = @(
    program := tape.cur ? program.match_close : program.advanced
  )!

  result =
    is_open_bracket ? run_open_bracket :
    is_close_bracket ? run_close_bracket :
    is_lt ? run_lt :
    is_gt ? run_gt :
    is_plus ? run_plus :
    is_minus ? run_minus :
    is_dot ? run_dot :
    is_done
      ? stop
      : step!
}

# Override this to create a unit test, where conditions are
# implemented in definitions 'a' through 'e'
unit_test = {
  a = 1, b = 1, c = 1, d = 1, e = 1
  result = a && b && c && d && e
}

# Classic hello world
result = Interpreter[code=">++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]<++.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>-]<+."]!

# Below example prints 2*2 = "\x04"
# result = Interpreter[code="++[->++<]>."]!
