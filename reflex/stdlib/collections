# A fixed-len list that is filled with some default value.
#
# Lists are created with an initial length and value.
# For example, to create a list of 10 elements that is full of the
# empty string, you can do:
#
#     list = List(len=10 value="")
#
# Lists can be randomly accessed or modified.
# For example, you can get a value:
#
#     item = list.at(idx=3)
#
# And set a value:
#
#     new_list = list.set(idx=3 value="hi")!`
#
List = {
  len = 0
  value = 0
  left = @(len:=_left_len)
  right = @(len:=_right_len)

  at = {
    result = idx < 0 || idx >= ^.len
      ? "index out of range".panic
      : ^.len == 1
        ? ^.value 
        : idx < ^.left.len
          ? ^.left.at(idx := idx)!
          : ^.right.at(idx := idx - ^.left.len)!
  }

  set = {
    result = idx < 0 || idx >= ^.len
      ? ("index " + idx.str + " is out of range").panic
      : ^.len == 1
        ? ^(value:=value)
        : idx < ^.left.len
          ? ^(
              left := ^.left.set(idx:=idx, value:=value)!
              right := ^.right
            )
          : ^(
              right := ^.right.set(idx := idx - ^.left.len, value := value)!
              left := ^.left
            )
  }

  map = { # args: (expr) or (fn)
    x = ^
    _offset = 0
    fn = {
      result = ^(idx:=idx x:=x).expr
    }
    _result = x.len == 0
      ? x
      : x.len == 1
        ? x(value:=fn(x:=x.value, idx:=_offset)!)
        : x(
            left := @(x:=x.left, _offset:=_offset)!
            right := @(x:=x.right, _offset:=_offset+x.left.len)!
          )
    result = @(fn:=fn)._result
  }

  filter = { # args: (expr) or (fn)
    x = ^
    fn = {
      result = ^(x:=x idx:=idx).expr
    }
    out = ^^.List(len=x.len)
    out_idx = 0
    in_idx = 0
    cur = x.at(idx=in_idx)!
    _result = in_idx == x.len
      ? ^^.List(len=out_idx).set_range(arr:=out)!
      : fn(x:=cur idx:=in_idx)!
        ? @(
            out_idx := out_idx+1
            in_idx := in_idx+1
            out := out.set(idx:=out_idx value:=cur)!
          )!
        : @(in_idx:=in_idx+1)!
    result = @(fn:=fn)._result
  }

  sum = {
    zero = 0
    result = ^.len == 0
      ? zero
      : ^.len == 1
        ? ^.value
        : ^.left.sum(zero:=zero)! + ^.right.sum(zero:=zero)!
  }

  join = {
    zero = ""
    separator = ""
    result = ^.len == 0
      ? zero
      : ^.len == 1
        ? ^.value
        : (
            ^.left.join(zero:=zero separator:=separator)!
            + separator
            + ^.right.join(zero:=zero separator:=separator)!
          )
  }

  set_range = {
    src_offset = 0
    result = src_offset + ^.len <= 0 || src_offset >= arr.len
      ? ^
      : ^.len != 1
        ? ^(
            left:=^.left.set_range(src_offset:=src_offset, arr:=arr)!
            right:=^.right.set_range(src_offset:=src_offset + ^.left.len, arr:=arr)!
          )
        : ^(value:=arr.at(idx:=src_offset)!)
  }

  add = {
    x = ^
    _result = ^^.List(len=x.len + y.len).set_range(src_offset=0 arr=x)!.set_range(src_offset=-x.len, arr:=y)!
    result = @(y:=y)._result
  }

  range = { # args: (start, end, stride)
    start = 0
    end = 0
    stride = 1

    len = stride > 0
      ? start < end
        ? (end - start - 1) / stride + 1
        : 0
      : stride < 0
        ? start > end
          ? (start - end - 1) / -stride + 1
          : 0
        : 0

    _result = ^^.List(len:=len).map[expr=^.start + idx*^.stride]!

    result = @(start:=start end:=end stride:=stride len:=len)._result
  }

  slice = {
    end = ^.len
    result = ^^.List(len:=end - start).set_range(arr:=^ src_offset:=start)!
  }

  _left_len = len / 2
  _right_len = _left_len + len % 2
}
