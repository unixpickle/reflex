#########################
# Brainf*ck interpreter #
#########################

# Helper to perform the wraparound logic in a memory cell
wrap_int = {
  result = x.mod[y=256]!
}

# A stack which is prefilled with infinite zeroes.
Stack = {
  prefix = ^.Stack # infinite prefix of all 0's
  item = 0
  push = { # argument: x
    result = ^^.Stack[prefix=^.^, item=^.x]
  }
}

# A bidirectional tape, represented as one stack to the left
# and one to the right.
Tape = {
  left = ^.Stack
  right = ^.Stack

  # Current position of the tape is arbitrarily chosen to be the left's end
  cur = left.item

  move_right = @[
    left = ^.left.push[x=^.^.right.item]!
    right = ^.right.prefix
  ]
  move_left = @[
    left = ^.left.prefix
    right = ^.right.push[x=^.^.left.item]!
  ]

  increment = @[
    left = ^.left[item=^^.wrap_int[x=^^.cur.add[y=1]!]!]
  ]
  decrement = @[
    left = ^.left[item=^^.wrap_int[x=^^.cur.sub[y=1]!]!]
  ]

  # Unit test for moving around the tape; test! should be 1.
  test = ^^.unit_test[
    t = ^^.Tape.increment.move_right.increment.increment.move_left.move_left
    a = t.cur.eq[y=0]!
    b = t.move_right.cur.eq[y=1]!
    c = t.move_right.move_right.cur.eq[y=2]!
    d = t.move_right.move_right.move_right.cur.eq[y=0]!
    e = t.move_right.move_right.move_right.move_left.cur.eq[y=2]!
  ]
}

# Representation of the program source and the current instruction pointer.
# Override the 'code' definition to pass the program source as a string.
Program = {
  ip = 0 # instruction pointer

  cur_inst = code.substr[start=^.ip end=^.ip.add[y=1]!]!
  advanced = @[ip=^.ip.add[y=1]!]
  rewound = @[ip=^.ip.sub[y=1]!]

  # Jump to a matching close bracket for an open bracket, then advance.
  match_open = _match_open!
  _match_open = {
    depth = 0

    on_open = ^.advanced._match_open[depth=^.depth.add[y=1]!]!
    on_close = depth.le[y=1]!.select[
      true = ^^.advanced
      false = ^^.advanced._match_open[depth=^^.depth.sub[y=1]!]!
    ]!
    on_other = ^^.advanced._match_open[depth=^.depth]!

    result = ^^.cur_inst.eq[y="["]!.select[
      true = ^^.on_open
      false = ^^.cur_inst.eq[y="]"]!.select[
        true = ^^.on_close
        false = ^^.on_other
      ]!
    ]!
  }

  # Jump to a matching open bracket for a close bracket, then advance.
  match_close = _match_close!
  _match_close = {
    depth = 0

    on_close = ^.rewound._match_close[depth=^.depth.add[y=1]!]!
    on_open = depth.le[y=1]!.select[
      true = ^^.advanced
      false = ^^.rewound._match_close[depth=^^.depth.sub[y=1]!]!
    ]!
    on_other = ^^.rewound._match_close[depth=^.depth]!

    result = ^^.cur_inst.eq[y="]"]!.select[
      true = ^^.on_close
      false = ^^.cur_inst.eq[y="["]!.select[
        true = ^^.on_open
        false = ^^.on_other
      ]!
    ]!
  }

  # Unit test for matching brackets; result is 1 when passed. 
  test = ^^.unit_test[
    p = ^^.Program[code=".[.[..]<><>[]].[]"]
    a = p.cur_inst.eq[y="."]!
    b = p.advanced.match_open.ip.eq[y=14]!
    c = p.advanced.advanced.advanced.match_open.ip.eq[y=7]!
    d = p.advanced.advanced.advanced.match_open.rewound.match_close.ip.eq[y=4]!
    e = p[ip=13].match_close.ip.eq[y=2]!
  ]
}

# A code interpreter, which represents the current program state.
# Use the 'result' definition to get the terminated interpreter state,
# which will have accumulated output in the 'output' definition.
Interpreter = {
  program = ^^.Program[code=^.code]
  tape = ^^.Tape
  output = ""

  is_open_bracket = program.cur_inst.eq[y="["]!
  is_close_bracket = program.cur_inst.eq[y="]"]!
  is_lt = program.cur_inst.eq[y="<"]!
  is_gt = program.cur_inst.eq[y=">"]!
  is_plus = program.cur_inst.eq[y="+"]!
  is_minus = program.cur_inst.eq[y="-"]!
  is_dot = program.cur_inst.eq[y="."]!
  is_done = program.cur_inst.eq[y=""]!

  stop = @
  step = @[program=^.program.advanced]
  run_lt = step[tape=^.tape.move_left]
  run_gt = step[tape=^.tape.move_right]
  run_minus = step[tape=^.tape.decrement]
  run_plus = step[tape=^.tape.increment]
  run_dot = step[output=^.output.cat[y=^^.tape.cur.chr]!]
  run_open_bracket = @[
    program = ^.tape.cur.select[
      false = ^.^.program.match_open
      true = ^.^.program.advanced
    ]!
  ]
  run_close_bracket = @[
    program = ^.tape.cur.select[
      false = ^.^.program.advanced
      true = ^.^.program.match_close
    ]!
  ]

  result = is_open_bracket.select[
    true = ^^.run_open_bracket!
    false = ^^.is_close_bracket.select[
      true = ^^.run_close_bracket!
      false = ^^.is_lt.select[
        true = ^^.run_lt!
        false = ^^.is_gt.select[
          true = ^^.run_gt!
          false = ^^.is_plus.select[
            true = ^^.run_plus!
            false = ^^.is_minus.select[
              true = ^^.run_minus!
              false = ^^.is_dot.select[
                true = ^^.run_dot!
                false = ^^.is_done.select[
                  false = ^^.step!
                  true = ^^.stop
                ]!
              ]!
            ]!
          ]!
        ]!
      ]!
    ]!
  ]!
}

# Override this to create a unit test, where conditions are
# implemented in definitions 'a' through 'e'
unit_test = {
  a = 1, b = 1, c = 1, d = 1, e = 1
  result = a.bit_and[y=^.b]!.bit_and[y=^.c]!.bit_and[y=^.d]!.bit_and[y=^.e]!
}

# Classic hello world
result = Interpreter[code=">++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]<++.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>-]<+."]!.output

# Below example prints 2*2 = "\x04"
# result = Interpreter[code="++[->++<]>."]!.output
